/**
 * ActiveRideScreen - SAFE VERSION v2 1.6.20 Build 25
 * 
 * This version:
 * 1. Checks if SDK native module is available before using it
 * 2. Properly extracts ride params (handles both shapes)
 * 3. Calls hooks unconditionally (React requirement)
 * 4. Has extensive logging for debugging
 */

import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import {
  View,
  StyleSheet,
  Alert,
  Platform,
  StatusBar,
  Linking,
  BackHandler,
  TouchableOpacity,
  Text,
  NativeModules,
  ScrollView,
  Animated,
  PanResponder,
} from 'react-native';
import { useNavigation, useRoute, RouteProp, CommonActions } from '@react-navigation/native';
import { StackNavigationProp } from '@react-navigation/stack';

// Existing services
import locationService from '../services/location.service';
import socketService from '../services/socket.service';
import apiService from '../services/api.service';


// Types
import {
  ActiveRide,
  TripStatus,
  isTripActive,
  formatDistance,
  formatDuration,
} from '../types/ride.types';
import type { Location } from '../types';

// Navigation types
import { MainStackParamList } from '../navigation/RootNavigator';

// ============================================================================
// SDK AVAILABILITY CHECK - Runs at module load time
// ============================================================================
const checkSDKAvailability = (): boolean => {
  try {
    const { NavModule } = NativeModules;
    console.log('üîç [SDK CHECK] NativeModules.NavModule:', NavModule ? 'EXISTS' : 'NULL');
    
    if (!NavModule) {
      console.warn('‚ö†Ô∏è [SDK CHECK] NavModule is null - SDK not available');
      return false;
    }
    
    const hasInit = typeof NavModule.initializeNavigator === 'function';
    console.log('üîç [SDK CHECK] initializeNavigator:', hasInit ? 'EXISTS' : 'MISSING');
    
    return hasInit;
  } catch (error) {
    console.error('‚ùå [SDK CHECK] Error checking SDK availability:', error);
    return false;
  }
};

const IS_SDK_AVAILABLE = checkSDKAvailability();
console.log('üöÄ [SDK CHECK] Final result: SDK is', IS_SDK_AVAILABLE ? 'AVAILABLE ‚úÖ' : 'NOT AVAILABLE ‚ùå');

// ============================================================================
// CONDITIONAL SDK IMPORTS
// ============================================================================
let useGoogleNav: any = null;
let NavigationView: any = null;

if (IS_SDK_AVAILABLE) {
  try {
    console.log('üì¶ [SDK IMPORT] Attempting to import SDK hooks...');
    const sdkModule = require('@googlemaps/react-native-navigation-sdk');
    useGoogleNav = sdkModule.useNavigation;
    NavigationView = sdkModule.NavigationView;
    console.log('üì¶ [SDK IMPORT] useNavigation hook imported:', useGoogleNav ? 'SUCCESS ‚úÖ' : 'FAILED ‚ùå');
  } catch (error) {
    console.error('‚ùå [SDK IMPORT] Failed to import SDK:', error);
  }
}

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================
type ActiveRideScreenRouteProp = RouteProp<MainStackParamList, 'ActiveRide'>;
type ActiveRideScreenNavigationProp = StackNavigationProp<MainStackParamList, 'ActiveRide'>;

const API_BASE_URL = 'https://ethiocode-ai-pi-rideshare.onrender.com';

// ============================================================================
// MAIN COMPONENT - Routes to SDK or Fallback mode
// ============================================================================
const ActiveRideScreen = (props: any) => {
  console.log('üé¨ [ActiveRideScreen] Rendering, SDK available:', IS_SDK_AVAILABLE);
  
  if (IS_SDK_AVAILABLE && useGoogleNav) {
    console.log('üé¨ [ActiveRideScreen] Using SDK MODE');
    return <ActiveRideWithSDK {...props} />;
  } else {
    console.log('üé¨ [ActiveRideScreen] Using FALLBACK MODE (no SDK)');
    return <ActiveRideFallback {...props} />;
  }
};

// ============================================================================
// SDK MODE COMPONENT
// ============================================================================
const ActiveRideWithSDK = (props: any) => {
  console.log('üî∑ [WithSDK] Component function starting...');
  
  const navigation = useNavigation<ActiveRideScreenNavigationProp>();
  const route = useRoute<ActiveRideScreenRouteProp>();
  const [isPreparingNav, setIsPreparingNav] = useState(true);
  const [prepProgress, setPrepProgress] = useState(0);

  // *** SLIDER AT PICKUP ***

  const [sliderPosition, setSliderPosition] = useState(0);
  const [isSliding, setIsSliding] = useState(false);

  // *** PARAM EXTRACTION - Handle both shapes ***
  const params = route.params as any;
  const initialRide: ActiveRide = params?.ride ?? params;
  const routeData = params?.routeData ?? null;
  
  console.log('üî∑ [WithSDK] Extracted initialRide:', initialRide ? 'EXISTS' : 'NULL');
  console.log('üî∑ [WithSDK] Ride ID:', initialRide?.rideId);
  console.log('üî∑ [WithSDK] Status:', initialRide?.status);

  // *** SDK HOOK - Must be called unconditionally ***
  const navContext = useGoogleNav();
  const navigationController = navContext?.navigationController ?? null;
  const addListeners = navContext?.addListeners ?? (() => {});
  const removeListeners = navContext?.removeListeners ?? (() => {});
  
  console.log('üî∑ [WithSDK] navigationController:', navigationController ? 'EXISTS' : 'NULL');

  // Refs
  const navigationInitialized = useRef(false);
  const rideRef = useRef(initialRide);

  // Core state
  const [ride, setRide] = useState<ActiveRide>(initialRide);
  const [user, setUser] = useState<any>(null);
  const [driverLocation, setDriverLocation] = useState<Location | null>(null);
  const [heading, setHeading] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  const [navViewController, setNavViewController] = useState<any>(null);
  const [mapViewController, setMapViewController] = useState<any>(null);
  const [panelExpanded, setPanelExpanded] = useState(false);
  const [waitSeconds, setWaitSeconds] = useState<number | null>(null);
  const sliderX = useRef(new Animated.Value(0)).current;

  // Update ref when ride changes
  useEffect(() => {
    rideRef.current = ride;
  }, [ride]);

  // *** LOAD USER DATA ***
  useEffect(() => {
    const loadUser = async () => {
      try {
        const userData = await apiService.get('/driver/profile');
        setUser(userData);
        console.log('üî∑ [WithSDK] User loaded:', userData?.id);
      } catch (error) {
        console.error('‚ùå [WithSDK] Failed to load user:', error);
      }
    };
    loadUser();
  }, []);

  // *** NAVIGATION PREP DELAY ***
useEffect(() => {
  let progress = 0;
  const interval = setInterval(() => {
    progress += 2;
    setPrepProgress(progress);
    if (progress >= 100) {
      clearInterval(interval);
      setIsPreparingNav(false);
    }
  }, 100);
  
  return () => clearInterval(interval);
}, []);


  // *** SDK INITIALIZATION ***
  useEffect(() => {
    if (isPreparingNav || !navigationController || !navViewController) {
      console.warn('üî∑ [WithSDK] No navigationController - skipping SDK init');
      return;
    }

    let isMounted = true;

    const initializeNavigation = async () => {
      if (navigationInitialized.current) {
        console.log('üî∑ [WithSDK] Already initialized, skipping');
        return;
      }

      try {
        console.log('üî∑ [WithSDK] Calling navigationController.init()...');
        await navigationController.init();
        
        if (!isMounted) return;
        
        console.log('üî∑ [WithSDK] init() completed successfully! ‚úÖ');
        navigationInitialized.current = true;

        addListeners({
          onNavigationReady: async () => {
            console.log('üî∑ [WithSDK] onNavigationReady callback fired');
            // NOW set destination - navigation is truly ready
            if (rideRef.current?.status === 'en_route_to_pickup' && rideRef.current?.pickup) {
              console.log('üî∑ [WithSDK] Setting destination to pickup...');
              try {
                await navigationController.setDestinations([{
                  title: 'Pickup',
                  position: {
                    lat: rideRef.current.pickup.lat,
                    lng: rideRef.current.pickup.lng,
                  },
                }]);
                await navigationController.startGuidance();
                console.log('üî∑ [WithSDK] Guidance started! ‚úÖ');
              } catch (err) {
                console.error('‚ùå [WithSDK] Failed to set destination:', err);
              }
            }
          },
          onLocationChanged: (location: any) => {
            if (location) {
              setDriverLocation({
                latitude: location.lat,
                longitude: location.lng,
              });
            }
          },
          onArrival: async (event: any) => {
            console.log('üî∑ [WithSDK] onArrival:', event);
            
            // Auto-update status to at_pickup
            try {
              await apiService.put(`/rides/${rideRef.current.rideId}/status`, { status: 'at_pickup' });
              setRide(prev => ({ ...prev, status: 'at_pickup' }));
              
              // Notify rider that driver has arrived
              await apiService.post(`/rides/${rideRef.current.rideId}/notify-arrival`);
              console.log('üî∑ [WithSDK] Rider notified of arrival');
            } catch (err) {
              console.error('‚ùå [WithSDK] Failed to update arrival status:', err);
            }
            
            setPanelExpanded(true);
          },
        });
          
        

      } catch (error) {
        console.error('‚ùå [WithSDK] navigationController.init() FAILED:', error);
      }
    };

    initializeNavigation();

    return () => {
      isMounted = false;
      if (navigationController) {
        removeListeners({});
      }
    };
 }, [isPreparingNav, navigationController, navViewController, addListeners, removeListeners]);

// *** ACTION HANDLERS ***
const handleStatusChange = async (newStatus: TripStatus) => {
  console.log('üî∑ [WithSDK] Status change:', ride?.status, '->', newStatus);
  setIsLoading(true);
  
  try {
    // Update via API
    await apiService.put(`/rides/${ride.rideId}/status`, { status: newStatus });
    
    // Update local state
    setRide(prev => ({ ...prev, status: newStatus }));
    
    // Update navigation destination
    if (navigationController && navigationInitialized.current) {
      if (newStatus === 'in_trip' && ride?.destination) {
        await navigationController.setDestinations([{
          title: 'Dropoff',
          position: {
            lat: ride.destination.lat,
            lng: ride.destination.lng,
          },
        }]);
        await navigationController.startGuidance();
      } else if (newStatus === 'completed' || newStatus === 'cancelled') {
        await navigationController.stopGuidance();
      }
    }

    // Navigate back on completion or cancellation
      if (newStatus === 'completed' || newStatus === 'cancelled') {
        // Clean up navigation SDK
        if (navigationController) {
          try {
            await navigationController.stopGuidance();
            await navigationController.clearDestinations();
          } catch (cleanupError) {
            console.warn('üî∑ [WithSDK] Cleanup warning:', cleanupError);
          }
        }
        
        // Notify rider if cancelled
        if (newStatus === 'cancelled') {
          try {
            await apiService.post(`/rides/${ride.rideId}/notify-cancellation`);
          } catch (notifyError) {
            console.warn('üî∑ [WithSDK] Failed to notify rider:', notifyError);
          }
        }
        
        // Reset to HomeScreen
        navigation.dispatch(
          CommonActions.reset({
            index: 0,
            routes: [{ name: 'Home' }],
          })
        );
      }
  } catch (error) {
    console.error('‚ùå [WithSDK] Status change failed:', error);
    Alert.alert('Error', 'Failed to update ride status');
  } finally {
    setIsLoading(false);
  }
};

// *** SLIDER HANDLER ***
const handleSlideComplete = async () => {
  if (sliderPosition < 80) {
    // Reset if not slid far enough
    setSliderPosition(0);
    return;
  }
  
  setIsSliding(false);
  setIsLoading(true);
  
  try {
    // Update status to in_trip
    await apiService.put(`/rides/${ride.rideId}/status`, { status: 'in_trip' });
    setRide(prev => ({ ...prev, status: 'in_trip' }));
    
    // Set new destination for navigation
    if (navigationController && navigationInitialized.current && ride?.destination) {
      await navigationController.setDestinations([{
        title: 'Dropoff',
        position: {
          lat: ride.destination.lat,
          lng: ride.destination.lng,
        },
      }]);
      await navigationController.startGuidance();
      console.log('üî∑ [WithSDK] Navigation to dropoff started!');
    }
    
    setPanelExpanded(false);
    setSliderPosition(0);
  } catch (error) {
    console.error('‚ùå Failed to start trip:', error);
    Alert.alert('Error', 'Failed to start trip');
    setSliderPosition(0);
  } finally {
    setIsLoading(false);
  }
};
// *** SLIDER PAN RESPONDER ***
const sliderWidth = 280;
const thumbWidth = 60;
const maxSlide = sliderWidth - thumbWidth;

const panResponder = useRef(
  PanResponder.create({
    onStartShouldSetPanResponder: () => true,
    onMoveShouldSetPanResponder: () => true,
    onPanResponderGrant: () => {
      setIsSliding(true);
    },
    onPanResponderMove: (_, gestureState) => {
      const newX = Math.max(0, Math.min(gestureState.dx, maxSlide));
      sliderX.setValue(newX);
      setSliderPosition((newX / maxSlide) * 100);
    },
    onPanResponderRelease: () => {
      if (sliderPosition >= 80) {
        // Complete the slide
        Animated.spring(sliderX, {
          toValue: maxSlide,
          useNativeDriver: false,
        }).start(() => {
          handleSlideComplete();
        });
      } else {
        // Reset slider
        Animated.spring(sliderX, {
          toValue: 0,
          useNativeDriver: false,
        }).start();
        setSliderPosition(0);
      }
      setIsSliding(false);
    },
  })
).current;

  const handleCallRider = () => {
    if (ride?.rider?.phone) {
      Linking.openURL(`tel:${ride.rider.phone}`);
    } else {
      Alert.alert('Unable to Call', 'Rider phone number not available');
    }
  };

  const handleNavigateExternal = () => {
    const dest = ride?.status === 'en_route_to_pickup' ? ride?.pickup : ride?.destination;
    if (dest) {
      const url = `https://www.google.com/maps/dir/?api=1&destination=${dest.lat},${dest.lng}`;
      Linking.openURL(url);
    }
  };

  const getActionButtonConfig = () => {
    switch (ride?.status) {
      case 'en_route_to_pickup':
        return null; // No button - auto-arrival detection
      case 'at_pickup':
        return null; // Slider handles this
      case 'in_trip':
        return { label: 'Complete Trip', nextStatus: 'completed' as TripStatus, color: '#8B5CF6' };
      default:
        return null;
    }
  };
  const actionConfig = getActionButtonConfig();

  // *** RENDER ***
return (
    <View style={styles.container}>
      {/* Navigation Map - Full Screen */}
      {NavigationView && (
        <NavigationView
          style={styles.navMap}
          onNavigationViewControllerCreated={(controller: any) => {
            console.log('üó∫Ô∏è NavigationViewController created');
            setNavViewController(controller);
            // Enable speedometer and speed limit icon
            controller.setSpeedometerEnabled(true);
            controller.setSpeedLimitIconEnabled(true);
          }}
          onMapViewControllerCreated={(controller: any) => {
            console.log('üó∫Ô∏è MapViewController created');
            setMapViewController(controller);
          }}
        />
      )}


      
      {/* Loading Overlay */}
      {isPreparingNav && (
        <View style={styles.prepOverlay}>
          <Text style={styles.prepText}>Preparing navigation...</Text>
          <View style={styles.progressBarBg}>
            <View style={[styles.progressBarFill, { width: `${prepProgress}%` }]} />
          </View>
          <Text style={styles.prepSubtext}>
            Locating pickup: {ride?.pickup?.address}
          </Text>
        </View>
      )}

      {/* Bottom Card Overlay */}
      <TouchableOpacity 
        style={[styles.bottomOverlay, !panelExpanded && styles.bottomOverlayCollapsed]}
        onPress={() => setPanelExpanded(!panelExpanded)}
        activeOpacity={0.9}
      >
        {/* Collapsed View */}
        {!panelExpanded ? (
          <View style={styles.collapsedContent}>
            <View style={styles.dragHandle} />
            <Text style={styles.pickingUpText}>
              Picking up {ride?.rider?.name || 'Rider'}
            </Text>
            <Text style={styles.pickupAddress} numberOfLines={1}>
              {ride?.pickup?.address}
            </Text>
          </View>
        ) : (
          <>
            {/* Expanded View */}
            <View style={styles.dragHandle} />
            
            {/* Rider Info */}
            <View style={styles.riderRow}>
              <View>
                <Text style={styles.riderName}>{ride?.rider?.name || 'Rider'}</Text>
                <Text style={styles.riderRating}>‚≠ê {ride?.rider?.rating?.toFixed(1) || 'N/A'}</Text>
              </View>
              <TouchableOpacity style={styles.callButton} onPress={handleCallRider}>
                <Text style={styles.callButtonText}>üìû</Text>
              </TouchableOpacity>
            </View>

            {/* Destination */}
            <View style={styles.destinationRow}>
              <Text style={styles.destinationLabel}>
                {ride?.status === 'en_route_to_pickup' ? 'PICKUP' : 'DROPOFF'}
              </Text>
              <Text style={styles.destinationAddress} numberOfLines={2}>
                {ride?.status === 'en_route_to_pickup'
                  ? ride?.pickup?.address
                  : ride?.destination?.address}
              </Text>
            </View>
             {/* Wait Timer - only show at pickup */}
            {ride?.status === 'at_pickup' && waitSeconds !== null && (
              <View style={styles.waitTimerRow}>
                <Text style={styles.waitTimerLabel}>
                  {waitSeconds > 0 ? 'Grace Period' : 'Wait Time'}
                </Text>
                <Text style={[
                  styles.waitTimerValue,
                  { color: waitSeconds > 0 ? '#EF4444' : '#10B981' }
                ]}>
                  {waitSeconds > 0 
                    ? `${Math.floor(waitSeconds / 60)}:${(waitSeconds % 60).toString().padStart(2, '0')}`
                    : `+${Math.floor(Math.abs(waitSeconds) / 60)}:${(Math.abs(waitSeconds) % 60).toString().padStart(2, '0')}`
                  }
                </Text>
              </View>
            )}
           {/* Slider for at_pickup, regular button for other statuses */}
            {ride?.status === 'at_pickup' ? (
              <View style={styles.sliderContainer}>
                <View style={styles.sliderTrack}>
                  <Text style={styles.sliderHintText}>
                    {sliderPosition >= 80 ? 'Release to Start!' : 'Slide to Start Trip ‚Üí'}
                  </Text>
                  <Animated.View
                    style={[
                      styles.sliderThumb,
                      { transform: [{ translateX: sliderX }] }
                    ]}
                    {...panResponder.panHandlers}
                  >
                    <Text style={styles.sliderThumbText}>‚Üí</Text>
                  </Animated.View>
                </View>
              </View>
            ) : (
              actionConfig && (
                <TouchableOpacity
                  style={[styles.actionButton, { backgroundColor: actionConfig.color }]}
                  onPress={() => handleStatusChange(actionConfig.nextStatus)}
                  disabled={isLoading}
                >
                  <Text style={styles.actionButtonText}>
                    {isLoading ? 'Updating...' : actionConfig.label}
                  </Text>
                </TouchableOpacity>
              )
            )}

            {/* Cancel Button */}
            <TouchableOpacity
              style={styles.cancelButton}
              onPress={() => handleStatusChange('cancelled')}
              disabled={isLoading}
            >
              <Text style={styles.cancelButtonText}>Cancel Ride</Text>
            </TouchableOpacity>
          </>
        )}
      </TouchableOpacity>
    </View>
  );
};

// ============================================================================
// FALLBACK MODE COMPONENT (No SDK)
// ============================================================================
const ActiveRideFallback = (props: any) => {
  console.log('üü° [Fallback] Component rendering...');
  
  const navigation = useNavigation<ActiveRideScreenNavigationProp>();
  const route = useRoute<ActiveRideScreenRouteProp>();
  
  // Extract ride from params
  const params = route.params as any;
  const initialRide: ActiveRide = params?.ride ?? params;
  
  const [ride, setRide] = useState<ActiveRide>(initialRide);
  const [isLoading, setIsLoading] = useState(false);
  const [panelExpanded, setPanelExpanded] = useState(false);

  const handleStatusChange = async (newStatus: TripStatus) => {
    setIsLoading(true);
    try {
      await apiService.put(`/rides/${ride.rideId}/status`, { status: newStatus });
      setRide(prev => ({ ...prev, status: newStatus }));
      
      if (newStatus === 'completed' || newStatus === 'cancelled') {
        navigation.goBack();
      }
    } catch (error) {
      Alert.alert('Error', 'Failed to update ride status');
    } finally {
      setIsLoading(false);
    }
  };

  const getActionButtonConfig = () => {
    switch (ride?.status) {
      case 'en_route_to_pickup':
        return { label: "I've Arrived", nextStatus: 'arrived' as TripStatus, color: '#3B82F6' };
      case 'at_pickup':
        return { label: 'Start Trip', nextStatus: 'in_trip' as TripStatus, color: '#10B981' };
      case 'in_trip':
        return { label: 'Complete Trip', nextStatus: 'completed' as TripStatus, color: '#8B5CF6' };
      default:
        return null;
    }
  };
  
  const actionConfig = getActionButtonConfig();

  return (
    <View style={styles.container}>
      <View style={[styles.debugBanner, { backgroundColor: '#F59E0B' }]}>
        <Text style={styles.debugText}>üü° FALLBACK MODE</Text>
        <Text style={styles.debugSubtext}>Google Navigation SDK not available</Text>
      </View>

      <ScrollView style={styles.scrollContent}>
        <View style={styles.card}>
          <Text style={styles.cardTitle}>Ride Details</Text>
          <View style={styles.infoRow}>
            <Text style={styles.label}>Ride ID:</Text>
            <Text style={styles.value}>{ride?.rideId || 'Unknown'}</Text>
          </View>
          <View style={styles.infoRow}>
            <Text style={styles.label}>Status:</Text>
            <Text style={[styles.value, styles.statusBadge]}>{ride?.status || 'Unknown'}</Text>
          </View>
        </View>

        <View style={styles.card}>
          <Text style={styles.cardTitle}>Rider</Text>
          <Text style={styles.value}>{ride?.rider?.name || 'Unknown'}</Text>
        </View>

        <View style={styles.card}>
          <Text style={styles.cardTitle}>Destination</Text>
          <Text style={styles.address}>{ride?.destination?.address || 'Unknown'}</Text>
        </View>

        <View style={styles.card}>
          <Text style={styles.cardTitle}>Fare</Text>
          <Text style={styles.fareAmount}>${ride?.fare?.estimated?.toFixed(2) || '0.00'}</Text>
        </View>
      </ScrollView>

      <View style={styles.actionContainer}>
        {actionConfig && (
          <TouchableOpacity
            style={[styles.actionButton, { backgroundColor: actionConfig.color }]}
            onPress={() => handleStatusChange(actionConfig.nextStatus)}
            disabled={isLoading}
          >
            <Text style={styles.actionButtonText}>
              {isLoading ? 'Updating...' : actionConfig.label}
            </Text>
          </TouchableOpacity>
        )}
        <TouchableOpacity
          style={styles.cancelButton}
          onPress={() => handleStatusChange('cancelled')}
          disabled={isLoading}
        >
          <Text style={styles.cancelButtonText}>Cancel Ride</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};

// ============================================================================
// STYLES
// ============================================================================
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0F172A',
  },
  debugBanner: {
    backgroundColor: '#3B82F6',
    paddingVertical: 12,
    paddingHorizontal: 16,
    paddingTop: Platform.OS === 'android' ? (StatusBar.currentHeight || 24) + 12 : 50,
  },
  debugText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  debugSubtext: {
    color: '#fff',
    fontSize: 12,
    opacity: 0.8,
    marginTop: 4,
  },
  scrollContent: {
    flex: 1,
    padding: 16,
  },
  card: {
    backgroundColor: '#1E293B',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
  },
  cardTitle: {
    color: '#94A3B8',
    fontSize: 14,
    fontWeight: '600',
    marginBottom: 12,
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  label: {
    color: '#64748B',
    fontSize: 14,
  },
  value: {
    color: '#F1F5F9',
    fontSize: 16,
    fontWeight: '500',
  },
  statusBadge: {
    backgroundColor: '#3B82F6',
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 12,
    overflow: 'hidden',
    fontSize: 14,
  },
  address: {
    color: '#F1F5F9',
    fontSize: 16,
    lineHeight: 24,
  },
  fareAmount: {
    color: '#10B981',
    fontSize: 32,
    fontWeight: 'bold',
  },
  surgeText: {
    color: '#F59E0B',
    fontSize: 14,
    marginTop: 4,
  },
  secondaryButton: {
    backgroundColor: '#334155',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 8,
    marginTop: 12,
    alignItems: 'center',
  },
  secondaryButtonText: {
    color: '#F1F5F9',
    fontSize: 16,
    fontWeight: '500',
  },
  actionContainer: {
    padding: 16,
    paddingBottom: Platform.OS === 'ios' ? 34 : 16,
    backgroundColor: '#1E293B',
    borderTopWidth: 1,
    borderTopColor: '#334155',
  },
  actionButton: {
    paddingVertical: 18,
    borderRadius: 12,
    alignItems: 'center',
    marginBottom: 12,
  },
  actionButtonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  cancelButton: {
    paddingVertical: 14,
    borderRadius: 12,
    alignItems: 'center',
    backgroundColor: 'transparent',
    borderWidth: 1,
    borderColor: '#EF4444',
  },
  cancelButtonText: {
    color: '#EF4444',
    fontSize: 16,
    fontWeight: '600',
  },

  cancelButtonCollapsed: {
    marginTop: 12,
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#EF4444',
  },

  navMap: {
    flex: 1,
  },
  bottomOverlay: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: '#1E293B',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 20,
    paddingBottom: Platform.OS === 'ios' ? 34 : 20,
  },

  waitTimerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
    paddingVertical: 8,
    paddingHorizontal: 12,
    backgroundColor: '#0F172A',
    borderRadius: 8,
  },
  waitTimerLabel: {
    color: '#94A3B8',
    fontSize: 14,
  },
  waitTimerValue: {
    fontSize: 24,
    fontWeight: 'bold',
    fontVariant: ['tabular-nums'],
  },
  riderRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  riderName: {
    color: '#F1F5F9',
    fontSize: 18,
    fontWeight: '600',
  },
  riderRating: {
    color: '#94A3B8',
    fontSize: 14,
    marginTop: 2,
  },
  callButton: {
    backgroundColor: '#3B82F6',
    width: 50,
    height: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
  },
  callButtonText: {
    fontSize: 24,
  },
  destinationRow: {
    marginBottom: 16,
  },
  destinationLabel: {
    color: '#94A3B8',
    fontSize: 12,
    fontWeight: '600',
    marginBottom: 4,
  },
  destinationAddress: {
    color: '#F1F5F9',
    fontSize: 16,
  },
  fareRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  fareLabel: {
    color: '#94A3B8',
    fontSize: 14,
  },
 bottomOverlayCollapsed: {
    paddingVertical: 12,
  },
  collapsedContent: {
    alignItems: 'center',
  },
  dragHandle: {
    width: 40,
    height: 4,
    backgroundColor: '#64748B',
    borderRadius: 2,
    marginBottom: 12,
    alignSelf: 'center',
  },
  pickingUpText: {
    color: '#F1F5F9',
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 4,
  },
  pickupAddress: {
    color: '#94A3B8',
    fontSize: 14,
  },
  prepOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(15, 23, 42, 0.95)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
  },
  prepText: {
    color: '#F1F5F9',
    fontSize: 20,
    fontWeight: '600',
    marginBottom: 24,
  },
  progressBarBg: {
    width: '100%',
    height: 8,
    backgroundColor: '#334155',
    borderRadius: 4,
    overflow: 'hidden',
  },
  progressBarFill: {
    height: '100%',
    backgroundColor: '#3B82F6',
    borderRadius: 4,
  },
  prepSubtext: {
    color: '#94A3B8',
    fontSize: 14,
    marginTop: 16,
    textAlign: 'center',
  },
  sliderContainer: {
    marginVertical: 16,
  },
  sliderTrack: {
    width: 280,
    height: 60,
    backgroundColor: '#10B981',
    borderRadius: 30,
    justifyContent: 'center',
    alignSelf: 'center',
    overflow: 'hidden',
  },
  sliderHintText: {
    color: 'rgba(255,255,255,0.7)',
    fontSize: 16,
    fontWeight: '600',
    textAlign: 'center',
  },
  sliderThumb: {
    position: 'absolute',
    left: 4,
    width: 52,
    height: 52,
    backgroundColor: '#fff',
    borderRadius: 26,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 5,
  },
  sliderThumbText: {
    fontSize: 24,
    color: '#10B981',
    fontWeight: 'bold',
  },
});

export default ActiveRideScreen;